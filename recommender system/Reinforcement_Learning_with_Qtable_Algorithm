import pandas as pd
import numpy as np
import plotly.graph_objs as go
import plotly.io as pio
import os
import random
import math
from tqdm import tqdm
from sklearn.metrics import mean_squared_error
from scipy.stats import spearmanr
from multiprocessing import Pool, cpu_count
import uuid

# Create a simple plot
fig = go.Figure(data=[go.Scatter(x=[1, 2, 3], y=[4, 5, 6])])

# Save the plot as an HTML file
pio.write_html(fig, file='plot.html', auto_open=False)

# Assuming the dataset is in the same directory
SONGS_FILE = "Spotify_MPD_Feature_Engineered.csv"
S = 50  # Hyper Parameter
totReco = 0  # Number of total recommendation till now
startConstant = 5  # for low penalty in starting phase

# Read data
Songs = pd.read_csv(SONGS_FILE)
NFEATURE = Songs.shape[1] - 60  # Number of Features (excluding all columns before 'Artiste Popularity')

ratedSongs = set()
userRecommendations = {}  # Store user recommendations

# User data structure
users = {}

def register_user():
    name = input("Enter your name: ")
    age = int(input("Enter your age: "))
    gender = input("Enter your gender (M/F/O): ")
    country = input("Enter your country: ")
    edu_level = input("Enter your education level (Graduate/High School/Middle School/Undergraduate): ")

    if name in users:
        print("User already exists. Please login.")
        return None

    user_id = str(uuid.uuid4())
    users[user_id] = {"name": name, "age": age, "gender": gender, "country": country, "edu_level": edu_level, "features": np.zeros(NFEATURE + 4, dtype=np.float64), "rated_songs": set()}
    userRecommendations[user_id] = []  # Initialize user recommendations
    print(f"User {name} registered successfully. Your user ID is {user_id}")
    return user_id

def login_user():
    user_id = input("Enter your user ID: ")
    if user_id not in users:
        print("Invalid user ID. Please register first.")
        return None
    print(f"Welcome back, {users[user_id]['name']}!")
    return user_id

def get_user_data(user_id):
    if user_id not in users:
        return None
    return users[user_id]

def compute_utility(user_features, song_features, epoch, s=S):
    """ Compute utility U based on user preferences and song preferences """
    user_features = user_features.copy()
    song_features = song_features.copy()
    dot = user_features.dot(song_features)
    ee = (1.0 - 1.0 * math.exp(-1.0 * epoch / s))
    res = dot * ee
    return res

def get_song_features(song):
    """ Feature of particular song """
    if isinstance(song, pd.Series):
        features = song[12:-48].values  # Exclude all columns before 'Artiste Popularity' and after 'Genre_world-music'
        return features.astype(np.float64)  # Convert features to float64
    elif isinstance(song, pd.DataFrame):
        return get_song_features(pd.Series(song.loc[song.index[0]]))
    else:
        raise TypeError("{} should be a Series or DataFrame".format(song))

def get_song_genre(song):
    genres = []
    for col in Songs.columns[-48:]:
        try:
            if isinstance(song, pd.Series):
                value = song[col]
            else:
                value = getattr(song, col)

            if isinstance(value, pd.Series):
                if value.any():  # Check if any value in the Series is True
                    genres.append(col[6:])  # Remove the "Genre_" prefix
            elif value is True:
                genres.append(col[6:])  # Remove the "Genre_" prefix
        except AttributeError:
            pass  # Skip the attribute if it doesn't exist
    return genres

def initialize_q_table():
    """
    Initialize q_table with all values set to 0
    """
    q_table = np.zeros(NFEATURE + 4)
    return q_table

def epsilon_greedy_policy(q_table, epsilon):
    """
    Epsilon-greedy policy:
    With probability epsilon, choose random action
    """
    if np.random.uniform(0, 1) < epsilon:
        return True
    else:
        return False

def update_q_table(q_table, features, reward):
    """
    Update q_table with new q_value
    """
    features = features.astype(np.float64)  # Convert features to float
    q_table += features * reward
    print(f"Updated Q-table: {q_table}")  # Debugging statement

def choose_action(q_table, user_features, epsilon):
    """
    Choose an action (recommend a song) based on the Q-table and an exploration strategy
    """
    if epsilon_greedy_policy(q_table, epsilon):
        # Choose a random action (song)
        action = Songs.sample(1).index[0]
    else:
        # Choose the action (song) with the highest Q-value
        q_values = np.dot(q_table, user_features)
        action = Songs.index[q_values.argmax()]
    return action

def update_features(user_features, song_features, rating, t):
    """
    Update user features based on the song features and user rating
    """
    impact_factor = (rating - 3) / 2  # Scale the impact factor based on the rating (-1 to 1)
    user_features[:-4] = user_features[:-4].astype(np.float64)  # Convert user_features[:-4] to float64
    user_features[:-4] += song_features * impact_factor
    return user_features

def get_recommendations(q_table, user_features, user_id, liked_genres):
    """
    Get recommendations based on the learned Q-table or policy
    """
    q_values = np.dot(q_table, user_features)
    sorted_indices = q_values.argsort()[::-1]  # Sort indices in descending order
    
    recommendations = []
    for index in sorted_indices:
        song = Songs.loc[index]
        song_genres = get_song_genre(song)
        if q_values[index] > 0 and any(genre in liked_genres for genre in song_genres):
            recommendations.append(song)
        if len(recommendations) >= 10:
            break
    
    if not recommendations:
        # If no recommendations found based on liked genres, fallback to top Q-value songs
        for index in sorted_indices:
            if q_values[index] > 0:
                recommendations.append(Songs.loc[index])
            if len(recommendations) >= 10:
                break
    
    recommendations = pd.DataFrame(recommendations)
    
    # Provide justification for the recommendations
    justification = "The recommendations are based on your preferences, demographics, and the songs you have rated highly. "
    justification += "We have learned from your ratings and selected songs that align with your taste. "
    justification += "Songs that you rated lower have been filtered out to provide more relevant suggestions."
    
    print(f"User features: {user_features}")  # Debugging statement
    print(f"Q-values: {q_values}")  # Debugging statement
    return recommendations, justification

def iterative_mean(old, new, t):
    """ Compute the new mean, Added startConstant for low penalty in starting phase """
    t += startConstant
    return ((t - 1) / t) * old + (1 / t) * new

def reinforcement_learning(user_id, s=200, N=5, epsilon=0.5):
    global Songs
    Songs = Songs.copy()

    # Use user's features and rated songs
    user_data = get_user_data(user_id)
    user_features = user_data["features"]
    ratedSongs = user_data["rated_songs"]

    # Initialize Q-table
    q_table = initialize_q_table()

    print("Select song genres that you like")
    Genres = [col[6:] for col in Songs.columns[-48:]]  # Remove "Genre_" prefix from genre names
    for i in range(0, len(Genres)):
        print(str(i + 1) + ". " + Genres[i])
    choice = "y"
    liked_genres = set()
    while (choice.lower().strip() == "y"):
        num = input("Enter number associated with genre: ")
        liked_genres.add(Genres[int(num) - 1])
        choice = input("Do you want to add another genre? (y/n) ")
    for i in range(0, len(Genres)):
        if Genres[i] in liked_genres:
            user_features[i + 12] = 1.0 / len(liked_genres)  # Set feature values for liked genres

    # Update user features with demographic information
    user_data = get_user_data(user_id)
    user_features[-4] = user_data["age"] / 100  # Normalize age to 0-1 range
    user_features[-3] = 1 if user_data["gender"] == "M" else 0  # Binary encoding for gender
    user_features[-2] = 1 if user_data["country"] == "USA" else 0  # Binary encoding for country
    user_features[-1] = 1 if user_data["edu_level"] == "Graduate" else 0  # Binary encoding for education level

    print("\n\nRate following " + str(N) + " songs. So that we can know your taste.\n")
    for t in range(N):
        # Choose an action (recommend a song) based on the Q-table and an exploration strategy
        action = choose_action(q_table, user_features, epsilon)
        recommendation = Songs.loc[Songs.index == action]

        # Get user's rating (reward) for the recommended song
        recommendation_features = get_song_features(recommendation)
        featured_artists = recommendation['featured_artists'].iloc[0] if 'featured_artists' in recommendation.columns and not pd.isna(recommendation['featured_artists'].iloc[0]) else ''
        user_rating = input(f'How much do you like "{recommendation["Music"].iloc[0]}" by {recommendation["artname"].iloc[0]} {f"(feat. {featured_artists})" if featured_artists else ""} (Duration: {str(recommendation["Duration"].iloc[0])} mins) (Genre: {", ".join(get_song_genre(recommendation))}) (1-5): ')
        user_rating = int(user_rating)
        reward = user_rating / 5.0  # Scale rating from 1-5 to 0-1

        # Update user's features and rated songs (next state)
        user_features = update_features(user_features, recommendation_features, user_rating, t)
        ratedSongs.add(recommendation.index[0])
        next_state = user_features  # The next state is the updated user features

        # Update the Q-table based on the observed reward and next state
        update_q_table(q_table, user_features, reward)

    # Recommend songs based on the learned Q-table or policy
    recommendations, justification = get_recommendations(q_table, user_features, user_id, liked_genres)
    print("\n\nBased on your preferences, here are some recommendations for you:\n")
    for i, song in enumerate(recommendations.itertuples()):
        featured_artists = song.featured_artists if 'featured_artists' in recommendations.columns and not pd.isna(song.featured_artists) else ''
        print(f"{i+1}. {song.Music} by {song.artname} {f'(feat. {featured_artists})' if featured_artists else ''} (Duration: {str(song.Duration)} mins) (Genre: {', '.join(get_song_genre(song))})")
    
    print(f"\nJustification: {justification}")

def main():
    user_id = register_user()  # You can also use login_user() if the user already exists
    if user_id:
        reinforcement_learning(user_id)

if __name__ == "__main__":
    main()